Directory structure:
└── m-s-saurabh-8-queens-puzzle/
    ├── Analysis.py
    ├── HillClimbing.py
    ├── Node.py
    ├── README.txt
    └── SimulatedAnnealing.py

================================================
File: Analysis.py
================================================
import numpy as np
from HillClimbing import HillClimbing
from SimulatedAnnealing import SimulatedAnnealing
import warnings
import sys

NUM_STATES = 1000

def generate_state():
    return np.random.randint(8, size=8)

def print_results(num_moves):
    print("\nResults:")
    for algo_name, moves in num_moves.items():
        print(algo_name)
        print('-'*15)
        result_string = "Solved {}/{} cases ({:.2f}%).\nAverage # of moves to find soln:{:.2f}\n"\
                        .format(len(moves), NUM_STATES, len(moves)/NUM_STATES*100, np.mean(moves))
        print(result_string)

def update_progress(progress, total):
    percent  = progress/total*100
    sys.stdout.write('\r[{}] {:.2f}% {}/{} cases'.format('#'*int(percent/5)+'-'*(20-int(percent/5)), percent, progress, total))

if __name__ == "__main__":
    if len(sys.argv) > 1:
        try:
            NUM_STATES = int(sys.argv[0])
        except:
            print("Correct way to run this file is: 'python Analysis.py 1000'")
            print("This runs the algorithms on 1000 initial states.")
            sys.exit()
    np.random.seed(42)

    algos = ['HC-Steepest-Ascent', 'HC-First-Choice', 'HC-First-Choice (100 sidesteps)', 'Simulated-Annealing']
    num_moves = {algo: [] for algo in algos}

    # Generate random state
    states = [generate_state() for i in range(NUM_STATES)]

    print("Running algorithms...")
    for i, state in enumerate(states):
        # Solve with Hill Climbing
        hill = HillClimbing(state)
        # Steepest Ascent
        end_state, end_cost, is_plateau, moves = hill.steepest_ascent()
        if(end_cost == 0): num_moves[algos[0]].append(moves)
        # First Choice
        end_state, end_cost, is_plateau, moves = hill.first_choice()
        if(end_cost == 0): num_moves[algos[1]].append(moves)
        # First Choice (max. 100 sideways moves)
        end_state, end_cost, is_plateau, moves = hill.first_choice(100)
        if(end_cost == 0): num_moves[algos[2]].append(moves)

        sim = SimulatedAnnealing(state)
        # Simulated Annealing
        end_state, end_cost, moves = sim.solve()
        if(end_cost == 0): num_moves[algos[3]].append(moves)

        update_progress(i+1, NUM_STATES)

    with warnings.catch_warnings():
        warnings.simplefilter("ignore", category=RuntimeWarning)
        print_results(num_moves)


================================================
File: HillClimbing.py
================================================
from Node import Node 

class HillClimbing:
    def __init__(self, state):
        super().__init__()
        self.start_node = Node(state)

    def steepest_ascent(self, max_sidesteps=0):
        current_node = self.start_node
        current_cost = current_node.get_cost()
        moves = 0; side_steps = 0
        while True:
            next_child, next_cost = current_node.lowest_cost_child()
            if(next_cost > current_cost):
                return current_node.state, current_cost, (next_cost == current_cost), moves
            if(next_cost == current_cost):
                side_steps += 1
                if side_steps > max_sidesteps:
                    return current_node.state, current_cost, (next_cost == current_cost), moves
            else:
                side_steps = 0
            current_node, current_cost = next_child, next_cost
            moves += 1

    def first_choice(self, max_sidesteps=0):
        current_node = self.start_node
        current_cost = current_node.get_cost()
        moves = 0; side_steps = 0
        while True:
            next_child, next_cost = current_node.first_choice_child()
            if(next_cost > current_cost):
                return current_node.state, current_cost, (next_cost == current_cost), moves
            if(next_cost == current_cost):
                side_steps += 1
                if side_steps > max_sidesteps:
                    return current_node.state, current_cost, (next_cost == current_cost), moves
            else:
                side_steps = 0
            current_node, current_cost = next_child, next_cost
            moves += 1

if __name__ == "__main__":
    # Initial State
    start_state = (4,5,6,3,4,5,6,5)
    print("Initial state:")
    Node.visualize(start_state)

    hill = HillClimbing(start_state)
    print("Running Steepest-Ascent:")
    end_state, end_cost, is_plateau, moves = hill.steepest_ascent()
    status = "Plateau reached!" if is_plateau else "Local Minima reached!"
    print(status+" state:{} cost:{}".format(end_state, end_cost))
    Node.visualize(end_state)

    print("Running First-Choice (with 100 sidesteps):")
    end_state, end_cost, is_plateau, moves = hill.first_choice(100)
    status = "Plateau reached!" if is_plateau else "Local Minima reached!"
    print(status+" state:{} cost:{}".format(end_state, end_cost))
    Node.visualize(end_state)


================================================
File: Node.py
================================================
import numpy as np
from itertools import product

class Node:
    state = np.array([0,1,2,3,4,5,6,7])

    def __init__(self, column_positions):
        super().__init__()
        self.state = np.array(column_positions)
        
    def get_cost(self):
        return Node.state_cost(self.state)

    @staticmethod
    def state_cost(state):
        # Return the number of queens being attacked.
        cost = 0
        for index, queen in enumerate(state):
            cost += (np.count_nonzero(state == queen) - 1)
            cost += (np.count_nonzero(abs(state - queen) ==  abs(np.arange(8) - index)) - 1)
        return (cost // 2)

    def get_child_states(self):
        children = []
        for index, queen in product(range(8), range(8)):
            if(queen != self.state[index]):
                new_state = self.state.copy()
                new_state[index] = queen
                children.append(new_state)
        return children

    def random_child(self):
        new_state = self.state.copy()
        index = np.random.randint(8)
        choices = [a for a in range(8) if a != self.state[index]]
        new_state[index] = np.random.choice(choices)
        return Node(new_state), Node.state_cost(new_state)

    def first_choice_child(self):
        cost = self.get_cost()
        children = self.get_child_states()
        np.random.shuffle(children)
        side_state, side_cost = None, None
        for child in children:
            child_cost = Node.state_cost(child)
            if child_cost < cost:
                return Node(child), child_cost
            if side_state is None and child_cost == cost:
                side_state, side_cost = child, child_cost
        if side_state is not None:
            return Node(side_state), side_cost
        return Node(child), child_cost

    def lowest_cost_child(self):
        children = self.get_child_states()
        costs = [Node.state_cost(child) for child in children]
        best_child_index = np.argmin(costs)
        return Node(children[best_child_index]), costs[best_child_index]

    @staticmethod
    def visualize(state):
        board = [['.' for j in range(8)] for i in range(8)]
        for col, queen in enumerate(state):
            board[queen][col] = 'Q'
        print("-"*16)
        for line in board: print(" ".join(line))
        print("-"*16)

if __name__ == "__main__":
    # # Cost function test
    # print("Cost function test")
    # test_cost = {(4,5,6,3,4,5,6,5): 17, (4,0,6,3,4,5,6,5): 12, (4,5,6,4,4,5,6,5): 15}
    # for state, cost in test_cost.items():
    #     node = Node(state)
    #     calc_cost = node.get_cost()
    #     print("state:{} cost:{}".format(state, calc_cost))
    #     assert(cost == calc_cost)
    # print()

    # # Generate children
    # node = Node((4,5,6,3,4,5,6,5))
    # children = node.get_child_states()
    # print("Number of child states:{}".format(len(children)))
    # # for child in children:
    # #     print(child)

    # Get the best valued chlid
    node = Node((2,0,7,4,1,1,6,5))
    best_child, best_cost = node.lowest_cost_child()
    print("best child:{} score:{}".format(best_child.state, best_cost))




================================================
File: README.txt
================================================
HOW TO RUN
-----------
To run all the algorithms at once:
    'python Analysis.py'
By default it runs on 1000 random initial states. 
To specify the number of initial states to generate:
    'python Analysis.py 500'

To run only Hill-Climbing algorithms on one case: 'python HillClimbing.py'
To run only Simulated-Annealing on one case: 'python SimulatedAnnealing.py'

RESULTS
--------
- Both Hill-Climbing algorithms without any sideways moves can solve around 14% of all the test cases.
- With a maximum of 100 consecutive sideways moves allowed, they can both solve 94% of the test cases.

- Steepest-Ascent takes 4 steps on average when it finds the solution
- Whereas, 'First Choice' takes 6 steps on average.

- Simulated Annealing needs a significantly higher number of steps to solve the problem.
- The same was observed with many different scheduling functions: 500/(t^3), 0.2/log(t+1), 400x(0.99^t), 100/10^(t+1)

- With the schedule 500/(t^3) it solved ~60% of the cases and took around 231.5 steps per solved case on average.


================================================
File: SimulatedAnnealing.py
================================================
from Node import Node 
from math import log10, exp, log
from numpy.random import rand

class SimulatedAnnealing:
    MAX_TIME = 500

    def __init__(self, state):
        super().__init__()
        self.start_node = Node(state)

    def schedule(self, time):
        if time > self.MAX_TIME: return 0
        if(time == 0): time = 1e-10
        return 503/(time**3)
        # return 1000/10**(time+1)
        # return 0.01/log10(time+1)

    def solve(self):
        current_node = self.start_node
        current_cost = current_node.get_cost()
        next_cost = current_cost
        time = 0
        num1=0
        while True:
            T = self.schedule(time)
            if T == 0:
                break
            next_child, next_cost = current_node.random_child() 
            dE = (current_cost - next_cost) # Opposite sign cuz we have cost instead of value
            if dE > 0 or rand() < exp(dE/T):
                num1 += 1
                current_node, current_cost = next_child, next_cost
                if next_cost == 0:
                    break
            time += 1
        # print("Option 1:{}, Option 2:{}".format(num1, time-num1))
        return current_node.state, current_cost, time

if __name__ == "__main__":
    # Initial state
    start_state = (4,5,6,3,4,5,6,5)
    print("Initial state:")
    Node.visualize(start_state)

    print("Running Simulated-Annealing:")
    sim = SimulatedAnnealing(start_state)
    end_state, end_cost, moves = sim.solve()
    status = "Solution found!" if end_cost == 0 else "Annealing Ended."
    print(status+" state:{} cost:{}".format(end_state, end_cost))
    Node.visualize(end_state)


